ver 2022-03-20

Prog-X: scope
------------------

Releases:
- POC - subset of functionality on imp006 breakout board
- FT1 (Field Trial 1) - maximum possible functionality on imp006 breakout board
- FT2 (Field Trial 2) - full functionality on target board
- OS (Open Source) - open source version of FT2

Hardware:
- POC: standard imp006 breakout board
- FT1: imp006 breakout board + WiFi/BLE MIKROE-3542 ESP32-WROOM-32 + Ublox M8N GNSS
- FT2: a target board (imp006, BG95-M3 modem, MIKROE-3542, Ublox M8N, LIS2DH12, light sensor, user button)

- Subset of Configuration is hardcoded (POC only)
- Full runtime configuration - imp-Agent REST API (not in POC)
- Safeguards for non-effective cfg (not in POC)
- Recovery mode

- Data from sensors:
  - Temperature
  - Battery level (by voltage) (not in POC)

- Alerts:
  - Temperature High
  - Temperature Low
  - Battery Low (not in POC)
  - Shock Detected
  - Motion Started
  - Motion Stopped
  - Geofence Entered (not in POC)
  - Geofence Exited (not in POC)
  - Repossession Mode Activated (not in POC)
  - Tampering (not in POC, FT1)

- Location determination in the following order:
  - BLE beacons (not in POC),
  - GNSS,
  - WiFi networks (not in POC),
  - cell info

- Geofencing (one configurable zone) (not in POC)

- Motion start detection using Accelerometer

- Motion stop detection using Location (+ Accelerometer for confirmation)

- Repossession mode - activate tracking after some date (not in POC)

- Device is disconnected most of time
- Connected only when data sending to imp-agent is needed

- Back-off for GNSS fix (not in POC)

- No bufferization on imp-agent side
- Messages are forwarded to the cloud's REST API
  -- POST https://<cloud_api_url>/data
  -- Basic authentication - username/password are hardcoded
  -- Body with data in text (JSON) format
  -- Response code 200 from the cloud if the request/data is accepted
- The cloud's REST API is emulated on another imp

- Shipping mode - first wakeup by a user button (not in POC, FT1)

- Tampering detection by light sensor (not in POC, FT1)

- Super SIM OTA update (not in POC, FT1)

----------------------------------------
DETAILS
----------------------------------------
Data polling:
-------------
- Temperature
- Battery Level by voltage (not in POC)
- Light sensor (TBD) (not in POC, FT1)

Alerts
------
By event:
- Shock Detected
- Motion Started
- Motion Stopped
- Geofence Entered (not in POC)
- Geofence Exited (not in POC)

By polling:
- Temperature High
- Temperature Low
- Battery Low (not in POC)
- Repossession Mode Activated (TBD) (not in POC)
- Tampering (TBD) (not in POC, FT1)

Activation after Shipping (not in POC, FT1)
-------------------------
TBD. Initial thoughts:
- After the first start (at factory ?) the app should go into deep sleep (?) - so called "shipping mode".
- There is a "button". It is "pressed" by a "user" when the device should start functioning (goes out from "shipping" mode).
- After that the app wakes up, sends the first report and starts normal working.
- The app should never go into deep sleep again.
- No more reactions to the "button".

Initialization Function (called after Imp restart)
-----------------------
- (not in POC, FT1) TBD - Recognize is it the first start, the wakeup from "shipping" mode or just a restart in a normal work.
- Recognize if there is a need to go to "recovery/emergency mode".
- (not in POC) Read from a permanent memory: configuration, latest location, latest status (TBD).
- (not in POC) Check if there is a new cfg from imp-Agent - TBD
- Initialize and start modules according to the current configuration and status - TBD.
- Disconnect imp-device
- Set Data Sending Timer

Shock Detection Callback
------------------------
- Set Shock Detected alert 
- Call Data Reading Function

Data Reading Timer Callback
---------------------------
- Call Data Reading Function

Data Reading Function
---------------------
- Cancel Data Reading Timer (if any)
- Read current data
  -- Temperature
  -- Battery Level (not in POC)
- Check alert events
  -- Alert event happens in case of a transition: non-alert condition (at the previous reading) -> alert condition (at the current reading)
- Create and save message:
  -- The following is included into the message:
     - TrackerId (deviceId)
     - Current timestamp (timestamp when data were read)
     - Current alert events (if any, by event or by polling)
     - Current read data
     - Saved the latest location
     - Current status: inMotion, TBD
  -- Send the message to ReplayMessenger:
     - It is not automatically sent to imp-agent, because imp-device is disconnected (in the most of cases)
- If there is at least one alert event (by event or by polling):
  -- Call Data Sending Function
- Set Data Reading Timer

Data Sending Timer Callback
---------------------------
- Call Data Sending Function

Data Sending Function
---------------------
- Cancel Data Sending Timer (if any)
- Connect imp-device
- Try to send all saved messages (if any)
  -- This is done automatically by ReplayMessenger
- When all messages are sent or data sending is too long (TBD), disconnect imp-device
- Set Data Sending Timer

Motion Detected Callback
------------------------
- Set motionStopAssumption = false
- If inMotion is false:
  -- (Motion start is detected)
  -- Set inMotion = true
  -- Cancel Location Reading Timer (if any, just in case)
  -- Call Location Reading Function
  -- Set Location Reading Timer
  -- Set Motion Started alert
  -- Call Data Reading Function

Location Reading Timer Callback
-------------------------------
- If motionStopAssumption is true:
  -- (Motion stop is confirmed)
  -- Set inMotion = false
  -- Set motionStopAssumption = false
  -- Set Motion Stopped alert
  -- Call Data Reading Function
- Otherwise:
  -- Call Location Reading Function
  -- Call Check Motion Stop Function
  -- If Geofencing is configured, call Check Geofencing Function (not in POC)
  -- Set Location Reading Timer

Location Reading Function
-------------------------
- Save the latest location as the previous location
- Try to determine the current location in the following order (till successfully determined):
  -- By BLE beacons (not in POC)
  -- By GNSS fix
  -- By WiFi hotspots (not in POC)
  -- By Cellular info
- If the current location is determined, save it as the latest location and mark it as fresh
- Otherwise, save the previous location as the latest location and mark it as non-fresh

Check Motion Stop Function
--------------------------
- If the latest location is fresh, check if the location is changed:
  -- Compare the previous and the latest locations, taking into account location accuracy and some difference threshold (TBD)
- If the location is not changed or the both, latest and previous, locations are non-fresh (ie. the location was not determined two times in a raw):
  -- (It might be that the motion is stopped, need to check/confirm that: if no motion is detected during the next location reading period => consider the motion is stopped)
  -- Set motionStopAssumption = true
  -- Enable Motion Detection

_curLocFresh && _prevLocFresh => compare
_curLocFresh && !_prevLocFresh => compare
!_curLocFresh && _prevLocFresh => do nothing
!_curLocFresh && !_prevLocFresh => _motionStopAssumption

Check Geofencing Function (not in POC)
-------------------------
- If the latest location is fresh:
  -- Calculate/check if the location is inside or outside the geofencing zone, set the current flag (inside/outside).
  -- Compare with the saved previous flag (inside/outside).
  -- If the flags are different:
     - Set Geofence Entered / Geofence Exited alert 
     - Call Data Reading Function
  -- Save the current flag as the previous one

- Repossession mode - activate tracking after some date (not in POC)
---------------------------------------------------
TBD

Northbound API (Data sending to the cloud)
------------------------------------------
- POST https://<cloud_api_url>/data
- Basic authentication - username/password are hardcoded (in POC) or configured (TBD, not in POC)
- Body with data in text (JSON) format
- Response code 200 from the cloud if the request/data is accepted
- No bufferization on imp-agent side
  -- Message received from imp-device is immediately sent to the cloud
  -- If OK is returned by the cloud, the message is ack-ed
  -- If an error is returned by the cloud, the message is not ack-ed

Data Message JSON
-----------------
{
   "trackerId": "c0010c2a69f088a4", // imp deviceId
   "timestamp": 1617900077, // Unix time, timestamp when data were read
   "status": {
     "tracking": true, // location obtaining is active
     "repossession": false, // in repossession mode 
     "inMotion": true
   },
   "location": {
     "fresh": true, // false - if the latest location has not beed determined, the provided data is the previous location
     "timestamp": 1617900070, // Unix time, timestamp when this location was determined
     "type": "gnss", // Possible values: "ble", "gnss", "wifi+cell", "wifi", "cell"
     "accuracy": 3, // in meters
     "lng": 30.571465,
     "lat": 59.749069
   },
   "sensors": {
     "batteryLevel": 64.32, // in %
     "temperature": 42.191177 // in Celsius
   },
   "alerts": [ // optional. Array of strings. Possible values: "temperatureHigh", "temperatureLow", "batteryLow", "shockDetected", "motionStarted", "motionStopped", "geofenceEntered", "geofenceExited", "repossessionActivated", "tamperingDetected"
     "temperatureHigh",
     "shockDetected"
   ]
}

Southbound API (Configuration sending from the cloud) (not in POC)
-----------------------------------------------------

Definitions:
- Full cfg - contains all fields.
- Partial cfg - contains a subset of fields.
- Default cfg - hardcoded configuration. Always a full cfg. Always exists. Can be different for different builds (different production flavors, different in development builds).
- Saved cfg - configuration saved in the flash. Always a full cfg.
- Reported cfg - known actual configuration of the tracker. Always a full cfg.
- Reported cfg contains three parts:
  -- description (always exists),
  -- configuration itself (does not exist if actual configuration is not known),
  -- debug features - standalone part of configuration related to debug, eg. log level (may exist partially, eg. for Imp-Agent part only).
- Cfg update - configuration update from the cloud. Can be full or partial cfg. Note, some of the fields can be updated/specified together only.
- Pending cfg update - cfg update which is not applied yet, waiting for the tracker becomes online.
- There can be not more than one pending cfg update at a time. A new cfg update from the cloud overwrites the current pending cfg update (if any).
- Every cfg update has a unique Id specified by the cloud (default cfg has predefined Id).
- Reported cfg includes Id of the latest applied cfg update.
- Debug features can be processed separately from the configuration. For example:
  -- Log level on Imp-Agent is updated immediately, even if the configuration is pending.
  -- Log level on Imp-Device can be updated even if the configuration is rejected.

Imp-Agent implements REST API:

  1) GET /cfg
    - Returns reported cfg.
    - Every time after cfg update (or default/saved cfg) is applied, Imp-Device reports actual configuration to Imp-Agent. Imp-Agent saves it as reported cfg.
    - If actual configuration is not known (Imp-Device has not reported its cfg yet after Imp-Agent is restarted), then only description is returned, w/o configuration itself.

  2) PATCH /cfg
    - Request for cfg update.
    - Imp-Agent checks the correctness of the configuration (type of field values, supported range of field values, all fields which can be updated together only are specified). If something is wrong, the request is failed and an error is responded.
    - If Imp-Device is online, then cfg update is immediately sent to Imp-Device. 
    - Otherwise, the request becomes pending cfg update, till Imp-Device becomes online. If there was another pending cfg, it is overwritten by the new one.
    - Debug features related to Imp-Agent are applied immediately.

JSON format:
- all keys and values are case sensitive

{
"description": {              // description, read-only
                              //   - does not exist in cfg update
                              //   - always exists in reported cfg

  "trackerId": <string>,        // unique tracker Id (imp deviceId)
  "cfgSchemeVersion": <string>, // supported JSON cfg format/scheme version: "<major>.<minor>"
  "cfgTimestamp": <number>,     // timestamp (Unix time) when the latest cfg update has been applied
                                //   Does not exist if actual cfg is not known at this moment,
                                //   "configuration" does not exist in this case either.
  "pendingUpdateId": <string>   // id of the pending cfg update. Does not exist if there is no pending cfg at this moment.
},

"configuration": {            // configuration
                              //   - in cfg update: can be full or partial cfg
                              //   - in reported cfg: always full cfg. Does not exist if actual cfg is not known at this moment.

  "updateId": <string>,         // unique Id of the cfg update:
                                //   - must be specified for every cfg update
                                //   - in reported cfg: Id of the last known applied update

  "locationTracking": {         // location obtaining is activated if any of the following occurs:
                                //   1) "alwaysOn" is true
                                //   2) "motionMonitoring" is enabled and the tracker is in motion
                                //   3) "repossessionMode" is enabled and the current timestamp is greater than the specified one

    "locReadingPeriod": <number>, // how often the tracker reads location when location obtaining is activated, in seconds,
                                  // [LOC_READING_SAFEGUARD_MIN..LOC_READING_SAFEGUARD_MAX]

    "alwaysOn": true/false,       // true - location obtaining is always activated

    "motionMonitoring": {         // motion start/stop monitoring. When in motion, location obtaining becomes activated
      "enabled": true/false,        // true - motion monitoring is enabled
                                    // motion start detection settings
                                    // movement acceleration threshold range [movementAccMin..movementAccMax]:
                                      // can be updated together only, movementAccMax >= movementAccMin
      "movementAccMin": <number>,     // minimum (starting) level, in g, [>0..TBD]
      "movementAccMax": <number>,     // maximum level, in g, [>0..TBD],
      "movementAccDur": <number>,   // duration of exceeding movement acceleration threshold, in seconds, [>0..TBD]
      "motionTime": <number>,       // maximum time to determine motion detection after the initial movement, in seconds,
                                    // [MOTION_TIME_SAFEGUARD_MIN..MOTION_TIME_SAFEGUARD_MAX]
      "motionVelocity": <number>,   // minimum instantaneous velocity to determine motion detection condition, in meters per second,
                                    // [MOTION_VEL_SAFEGUARD_MIN..MOTION_VEL_SAFEGUARD_MAX]
      "motionDistance": <number>    // minimum movement distance to determine motion detection condition, in meters,
                                    // [0, MOTION_DIST_SAFEGUARD_MIN..MOTION_DIST_SAFEGUARD_MAX]
                                    // (if 0, distance is not calculated, ie. not used for motion detection)
    },

    "repossessionMode": {         // location obtaining activation after some date
      "enabled": true/false,        // true - repossession mode is enabled
      "after": <string>             // UNIX timestamp after which location obtaining is activated, >SOME_RESONABLE_TIMESTAMP
    },

    "bleDevices": {               // Bluetooth Low Enegry (BLE) devices for location obtaining
      "enabled": true/false,        // true - location obtaining using BLE devices is enabled
      "generic": {                  // new set of generic devices - fully replaces the previous set of generic devices
        <mac>: {                     // device identifier (MAC address). Example: "db9786256c43"
                                      // location - lng, lat - can be specified together only
          "lng": <number>,            // longitude, in degrees, [-180..180]
          "lat": <number>             // latitude, in degrees, [-90..90]
        },
        ...
      },
      "iBeacon": {                  // new set of iBeacon devices - fully replaces the previous set of iBeacon devices
        <uuid>: {                     // group UUID (16 bytes). Example: "74d2515660e6444ca177a96e67ecfc5f"
          <major>: {                    // sub-group identifier, number from 0 to 65535
            <minor>: {                    // device identifier, number from 0 to 65535
                                            // location - lng, lat - can be specified together only
              "lng": <number>,              // longitude, in degrees, [-180..180]
              "lat": <number>               // latitude, in degrees, [-90..90]
            },
            ...
          },
          ...
        },
        ...
      }
    },

    "geofence": {                 // circle geofence (center, radius) TBD
      "enabled": true/false,        // true - geofence is enabled
                                    // lng, lat, radius - can be updated together only
      "lng": <number>,              // center longitude, in degrees, [-180..180]
      "lat": <number>,              // center latitude, in degrees, [-90..90]
      "radius": <number>            // radius, in meters, [0..EARTH_RADIUS]
    }
  },

  "connectingPeriod": <number>, // how often the tracker connects to network, in seconds,
                                // [CONNECTING_SAFEGUARD_MIN..CONNECTING_SAFEGUARD_MAX]

  "readingPeriod": <number>,    // how often the tracker polls various data, in seconds,
                                // [READING_SAFEGUARD_MIN..READING_SAFEGUARD_MAX]

  "alerts": {                   // additional (not tracking related) alerts

    "shockDetected" : {           // one-time shock acceleration
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>         // shock acceleration alert threshold, in g,
                                    // [SHOCK_ACC_SAFEGUARD_MIN..SHOCK_ACC_SAFEGUARD_MAX]
    },

    "temperatureLow": {           // temperature crosses the border (becomes below the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>,        // temperature low alert threshold, in Celsius
      "hysteresis": <number>        // "hysteresis" to avoid alerts "bounce", in Celsius, >=0
    },

    "temperatureHigh": {          // temperature crosses the border (becomes above the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>,        // temperature high alert threshold, in Celsius
      "hysteresis": <number>        // "hysteresis" to avoid alerts "bounce", in Celsius, >=0
    },

    "batteryLow": {               // battery level crosses the border (becomes below the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>         // battery low alert threshold, in %, [0..100]
    },

    "tamperingDetected": {        // TBD
      "enabled": true/false        // true - alert is enabled
    }
  }
},

"debug": {                 // debug features
  "agentLogLevel": "DEBUG",  // logging level on Imp-Agent ("ERROR", "INFO", "DEBUG")
  "deviceLogLevel": "INFO"   // logging level on Imp-Device ("ERROR", "INFO", "DEBUG")
}
}

Cfg processing on Imp-Device
----------------------------

- Every module has constructor/start() (TBD) where full cfg is provided.
- The module extracts the needed fields, makes setup and starts working.
- It is assumed that always full and correct cfg is provided. No need in defaults and additional checks (except few cases).
- If any problem, the module throws an exception.

- Every module has an additional updateCfg() method where cfg update is provided.
- The module extracts the fields related to it (if any) and makes an update in settings. How is it done - is a module-specific.
- It is assumed that always correct cfg update is provided. No need in defaults and additional checks (except few cases).
- If any problem, the module throws an exception.

After Imp-Device restart:
  - If it is a new deployment and ERASE_FLASH builder-variable is defined, erase the flash.
  - If there is saved cfg in the flash, actual_cfg = saved cfg, use it to setup and start all modules.
    -- If an exception or any other problems (eg. with reading cfg from the flash), log the error, erase saved cfg in the flash and restart Imp-Device.
  - If there is no saved cfg in the flash, actual_cfg = default cfg, use it to setup and start all modules.
    -- If an exception, log the error, go to recovery mode (TBD).
  - If all modules are started w/o problems, send actual_cfg to Imp-Agent.

When cfg update comes from Imp-Agent:
  - Wait (using Promises or whatever, TBD) till any other cfg setup/update process is completed. Including completion of initial setup after Imp-Device restart.
  - I.e. actual_cfg always exists.
  - Make a diff between actual_cfg and cfg update.
  - Call updateCfg(diff) for all modules.
    -- If an exception, log the error, restart Imp-Device.
  - If no problems:
    -- actual_cfg = actual_cfg + diff
    -- save actual_cfg in the flash
       - if problems - ignore / erase flash (TBD)
    -- send actual_cfg to Imp-Agent.
  - When to confirm cfg update message receiving - TBD

Recovery Mode
-------------
If an unhandled error occurred (or there are other conditions when need to go to the recovery mode - TBD), device goes to sleep and periodically connects to the server waiting for a SW update
