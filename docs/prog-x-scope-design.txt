ver 2022-01-10

Prog-X: scope
------------------

Releases:
- POC - subset of functionality on imp006 breakout board
- FT1 (Field Trial 1) - maximum possible functionality on imp006 breakout board
- FT2 (Field Trial 2) - full functionality on target board
- OS (Open Source) - open source version of FT2

Hardware:
- POC: standard imp006 breakout board
- FT1: imp006 breakout board + WiFi/BLE MIKROE-3542 ESP32-WROOM-32 + Ublox M8N GNSS
- FT2: a target board (imp006, BG95-M3 modem, MIKROE-3542, Ublox M8N, LIS2DH12, light sensor, user button)

- Subset of Configuration is hardcoded (POC only)
- Full runtime configuration - imp-Agent REST API (not in POC)
- Safeguards for non-effective cfg (not in POC)
- Recovery mode

- Data from sensors:
  - Temperature
  - Battery level (by voltage) (not in POC)

- Alerts:
  - Temperature High
  - Temperature Low
  - Battery Low (not in POC)
  - Shock Detected
  - Motion Started
  - Motion Stopped
  - Geofence Entered (not in POC)
  - Geofence Exited (not in POC)
  - Repossession Mode Activated (not in POC)
  - Tampering (not in POC, FT1)

- Location determination in the following order:
  - BLE beacons (not in POC),
  - GNSS,
  - WiFi networks (not in POC),
  - cell info

- Geofencing (one configurable zone) (not in POC)

- Motion start detection using Accelerometer

- Motion stop detection using Location (+ Accelerometer for confirmation)

- Repossession mode - activate tracking after some date (not in POC)

- Device is disconnected most of time
- Connected only when data sending to imp-agent is needed

- Back-off for GNSS fix (not in POC)

- No bufferization on imp-agent side
- Messages are forwarded to the cloud's REST API
  -- POST https://<cloud_api_url>/data
  -- Basic authentication - username/password are hardcoded
  -- Body with data in text (JSON) format
  -- Response code 200 from the cloud if the request/data is accepted
- The cloud's REST API is emulated on another imp

- Shipping mode - first wakeup by a user button (not in POC, FT1)

- Tampering detection by light sensor (not in POC, FT1)

- Super SIM OTA update (not in POC, FT1)

----------------------------------------
DETAILS
----------------------------------------
Data polling:
-------------
- Temperature
- Battery Level by voltage (not in POC)
- Light sensor (TBD) (not in POC, FT1)

Alerts
------
By event:
- Shock Detected
- Motion Started
- Motion Stopped
- Geofence Entered (not in POC)
- Geofence Exited (not in POC)

By polling:
- Temperature High
- Temperature Low
- Battery Low (not in POC)
- Repossession Mode Activated (TBD) (not in POC)
- Tampering (TBD) (not in POC, FT1)

Activation after Shipping (not in POC, FT1)
-------------------------
TBD. Initial thoughts:
- After the first start (at factory ?) the app should go into deep sleep (?) - so called "shipping mode".
- There is a "button". It is "pressed" by a "user" when the device should start functioning (goes out from "shipping" mode).
- After that the app wakes up, sends the first report and starts normal working.
- The app should never go into deep sleep again.
- No more reactions to the "button".

Initialization Function (called after Imp restart)
-----------------------
- (not in POC, FT1) TBD - Recognize is it the first start, the wakeup from "shipping" mode or just a restart in a normal work.
- Recognize if there is a need to go to "recovery/emergency mode".
- (not in POC) Read from a permanent memory: configuration, latest location, latest status (TBD).
- (not in POC) Check if there is a new cfg from imp-Agent - TBD
- Initialize and start modules according to the current configuration and status - TBD.
- Disconnect imp-device
- Set Data Sending Timer

Shock Detection Callback
------------------------
- Set Shock Detected alert 
- Call Data Reading Function

Data Reading Timer Callback
---------------------------
- Call Data Reading Function

Data Reading Function
---------------------
- Cancel Data Reading Timer (if any)
- Read current data
  -- Temperature
  -- Battery Level (not in POC)
- Check alert events
  -- Alert event happens in case of a transition: non-alert condition (at the previous reading) -> alert condition (at the current reading)
- Create and save message:
  -- The following is included into the message:
     - TrackerId (deviceId)
     - Current timestamp (timestamp when data were read)
     - Current alert events (if any, by event or by polling)
     - Current read data
     - Saved the latest location
     - Current status: inMotion, TBD
  -- Send the message to ReplayMessenger:
     - It is not automatically sent to imp-agent, because imp-device is disconnected (in the most of cases)
- If there is at least one alert event (by event or by polling):
  -- Call Data Sending Function
- Set Data Reading Timer

Data Sending Timer Callback
---------------------------
- Call Data Sending Function

Data Sending Function
---------------------
- Cancel Data Sending Timer (if any)
- Connect imp-device
- Try to send all saved messages (if any)
  -- This is done automatically by ReplayMessenger
- When all messages are sent or data sending is too long (TBD), disconnect imp-device
- Set Data Sending Timer

Motion Detected Callback
------------------------
- Set motionStopAssumption = false
- If inMotion is false:
  -- (Motion start is detected)
  -- Set inMotion = true
  -- Cancel Location Reading Timer (if any, just in case)
  -- Call Location Reading Function
  -- Set Location Reading Timer
  -- Set Motion Started alert
  -- Call Data Reading Function

Location Reading Timer Callback
-------------------------------
- If motionStopAssumption is true:
  -- (Motion stop is confirmed)
  -- Set inMotion = false
  -- Set motionStopAssumption = false
  -- Set Motion Stopped alert
  -- Call Data Reading Function
- Otherwise:
  -- Call Location Reading Function
  -- Call Check Motion Stop Function
  -- If Geofencing is configured, call Check Geofencing Function (not in POC)
  -- Set Location Reading Timer

Location Reading Function
-------------------------
- Save the latest location as the previous location
- Try to determine the current location in the following order (till successfully determined):
  -- By BLE beacons (not in POC)
  -- By GNSS fix
  -- By WiFi hotspots (not in POC)
  -- By Cellular info
- If the current location is determined, save it as the latest location and mark it as fresh
- Otherwise, save the previous location as the latest location and mark it as non-fresh

Check Motion Stop Function
--------------------------
- If the latest location is fresh, check if the location is changed:
  -- Compare the previous and the latest locations, taking into account location accuracy and some difference threshold (TBD)
- If the location is not changed or the both, latest and previous, locations are non-fresh (ie. the location was not determined two times in a raw):
  -- (It might be that the motion is stopped, need to check/confirm that: if no motion is detected during the next location reading period => consider the motion is stopped)
  -- Set motionStopAssumption = true
  -- Enable Motion Detection

_curLocFresh && _prevLocFresh => compare
_curLocFresh && !_prevLocFresh => compare
!_curLocFresh && _prevLocFresh => do nothing
!_curLocFresh && !_prevLocFresh => _motionStopAssumption

Check Geofencing Function (not in POC)
-------------------------
- If the latest location is fresh:
  -- Calculate/check if the location is inside or outside the geofencing zone, set the current flag (inside/outside).
  -- Compare with the saved previous flag (inside/outside).
  -- If the flags are different:
     - Set Geofence Entered / Geofence Exited alert 
     - Call Data Reading Function
  -- Save the current flag as the previous one

- Repossession mode - activate tracking after some date (not in POC)
---------------------------------------------------
TBD

Northbound API (Data sending to the cloud)
------------------------------------------
- POST https://<cloud_api_url>/data
- Basic authentication - username/password are hardcoded (in POC) or configured (TBD, not in POC)
- Body with data in text (JSON) format
- Response code 200 from the cloud if the request/data is accepted
- No bufferization on imp-agent side
  -- Message received from imp-device is immediately sent to the cloud
  -- If OK is returned by the cloud, the message is ack-ed
  -- If an error is returned by the cloud, the message is not ack-ed

Data Message JSON
-----------------
{
   "trackerId": "c0010c2a69f088a4", // imp deviceId
   "timestamp": 1617900077, // Unix time, timestamp when data were read
   "status": {
     "tracking": true, // location obtaining is active
     "repossession": false, // in repossession mode 
     "inMotion": true
   },
   "location": {
     "fresh": true, // false - if the latest location has not beed determined, the provided data is the previous location
     "timestamp": 1617900070, // Unix time, timestamp when this location was determined
     "type": "gnss", // Possible values: "gnss", "cell", "wifi", "ble"
     "accuracy": 3, // in meters
     "lng": 30.571465,
     "lat": 59.749069
   },
   "sensors": {
     "batteryLevel": 64.32, // in %
     "temperature": 42.191177 // in Celsius
   },
   "alerts": [ // optional. Array of strings. Possible values: "temperatureHigh", "temperatureLow", "batteryLow", "shockDetected", "motionStarted", "motionStopped", "geofenceEntered", "geofenceExited", "repossessionActivated", "tamperingDetected"
     "temperatureHigh",
     "shockDetected"
   ]
}

Southbound API (Configuration sending from the cloud) (not in POC)
-----------------------------------------------------

Definitions:
- Full cfg - contains all fields.
- Partial cfg - contains a subset of fields.
- Empty cfg - contains no fields.
- Default cfg - hardcoded configuration. Always a full cfg. Always exists. Can be different for different builds (different production flavors, different in development builds).
- Saved cfg - configuration saved in the flash. Always a full cfg.
- Reported cfg - known actual configuration of the tracker. Always a full cfg.
- Cfg update - configuration update from the cloud. Can be full or partial cfg.
- Pending cfg update - cfg update which is not applied yet, waiting for the tracker becomes online.
- There can be not more than one pending cfg update at a time. A new cfg update from the cloud overwrites the current pending cfg update (if any).
- Every cfg update has a unique Id specified by the cloud (default cfg has predefined Id).
- Reported cfg includes Id of the latest applied cfg update.

Imp-Agent implements REST API:

  1) GET /cfg
    - Returns reported cfg.
    - If no reported cfg known (when after Imp-Agent restart, Imp-Device has not reported it's cfg yet), then empty cfg is returned.
    - Every time after cfg update is processed by Imp-Device it sends actual configuration to Imp-Agent. Imp-Agent saves it as reported cfg.

  2) PUT (TBD) /cfg
    - Request for cfg update.
    - Imp-Agent checks the correctness of the configuration (type of field values, supported range of field values). If something is wrong, the request is failed and an error is responded.
    - If Imp-Device is online, then cfg update is immediately sent to Imp-Device. 
    - Otherwise, the request becomes pending cfg update, till Imp-Device becomes online. If there was another pending cfg, it is overwritten by the new one.

JSON format:
- all keys and values are case sensitive/insensitive - TBD

{
  "updateId": <string>,         // unique Id of the cfg update:
                                // - specified in the desired cfg
                                // - in the reported cfg: Id of the last known applied update

                                // These fields are read-only, exists in the reported cfg only
  "updateTimestamp": <number>,    // timestamp (Unix time) when this update has been applied
  "pendingUpdate": true/false,    // true - a new cfg update is pending (not applied yet)
  "pendingUpdateId: <string>,     // id of the pending cfg update. Exists if "pendingUpdate" is true
  "trackerId": <string>,          // unique tracker Id (imp deviceId)
  "cfgSchemeVersion": <string>,   // supported JSON cfg format/scheme version: "<major>.<minor>"

  "locationTracking": {         // location obtaining is activated if any of the following occurs:
                                //   1) "alwaysOn" is true
                                //   2) "motionMonitoring" is enabled and the tracker is in motion
                                //   3) "repossessionMode" is enabled and the current timestamp is greater than the specified one

    "locReadingPeriod": <number>, // how often the tracker reads location when location obtaining is activated, in seconds,
                                  // [LOC_READING_SAFEGUARD_MIN..LOC_READING_SAFEGUARD_MAX]

    "alwaysOn": true/false,       // true - location obtaining is always activated

    "motionMonitoring": {         // motion start/stop monitoring. When in motion, location obtaining becomes activated
      "enabled": true/false,        // true - motion monitoring is enabled
                                    // motion start detection settings
                                    // movement acceleration threshold range [min..max]:
      "movementAccMin": <number>,     // minimum (starting) level, in g, [>0..TBD]
      "movementAccMax": <number>,     // maximum level, in g, [>0..TBD],
                                      // if movementAccMax < movementAccMin, they are assumed equal to movementAccMin
      "movementAccDur": <number>,   // duration of exceeding movement acceleration threshold, in seconds, [>0..TBD]
      "motionTime": <number>,       // maximum time to determine motion detection after the initial movement, in seconds,
                                    // [MOTION_TIME_SAFEGUARD_MIN..MOTION_TIME_SAFEGUARD_MAX]
      "motionVelocity": <number>,   // minimum instantaneous velocity to determine motion detection condition, in meters per second,
                                    // [MOTION_VEL_SAFEGUARD_MIN..MOTION_VEL_SAFEGUARD_MAX]
      "motionDistance": <number>    // minimum movement distance to determine motion detection condition, in meters,
                                    // [0, MOTION_DIST_SAFEGUARD_MIN..MOTION_DIST_SAFEGUARD_MAX]
                                    // (if 0, distance is not calculated, ie. not used for motion detection)
    },

    "repossessionMode": {         // location obtaining activation after some date
      "enabled": true/false,        // true - repossession mode is enabled
      "after": <string>             // UNIX timestamp after which location obtaining is activated, >SOME_RESONABLE_TIMESTAMP
    },

    "bleBeacons": {               // BLE beacons for location obtaining
      "enabled": true/false,        // true - location obtaining using BLE beacons is enabled
      "beacons": {                  // set of beacons
        <id>: {                     // beacon unique identifier (MAC address)
          "lng": <number>,            // longitude, in degrees, [-90..90]
          "lat": <number>             // latitude, in degrees, [-90..90]
        },
        ...
      }
    },

    "geofence": {                 // circle geofence (center, radius)
      "enabled": true/false,        // true - geofence is enabled
      "lng": <number>,              // center longitude, in degrees, [-90..90]
      "lat": <number>,              // center latitude, in degrees, [-90..90]
      "radius": <number>            // radius, in meters, [EARTH_RADIUS..0]
    }
  },

  "connectingPeriod": <number>, // how often the tracker connects to network, in seconds,
                                // [CONNECTING_SAFEGUARD_MIN..CONNECTING_SAFEGUARD_MAX]

  "readingPeriod": <number>,    // how often the tracker polls various data, in seconds,
                                // [READING_SAFEGUARD_MIN..READING_SAFEGUARD_MAX]

  "alerts": {                   // additional (not tracking related) alerts

    "shockDetected" : {           // one-time shock acceleration
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>         // shock acceleration alert threshold, in g,
                                    // [SHOCK_ACC_SAFEGUARD_MIN..SHOCK_ACC_SAFEGUARD_MAX]
    },

    "temperatureLow": {           // temperature crosses the border (becomes below the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>,        // temperature low alert threshold, in Celsius
      "hysteresis": <number>        // "hysteresis" to avoid alerts "bounce", in Celsius, >=0
    },

    "temperatureHigh": {          // temperature crosses the border (becomes above the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>,        // temperature high alert threshold, in Celsius
      "hysteresis": <number>        // "hysteresis" to avoid alerts "bounce", in Celsius, >=0
    },

    "batteryLow": {               // battery level crosses the border (becomes below the threshold)
      "enabled": true/false,        // true - alert is enabled
      "threshold": <number>         // battery low alert threshold, in %, [0..100]
    },

    "tamperingDetected": {        // TBD
      "enabled": true/false        // true - alert is enabled
    }
  },

  "impLogging": {               // imp logging level ("ERROR", "INFO", "DEBUG")
    "agentLevel": "DEBUG",        // on Imp-Agent
    "deviceLevel": "INFO"         // on Imp-Device
  }
}

Cfg processing on Imp-Device
----------------------------

- Every module has constructor/start() (TBD) where full cfg is provided.
- The module extracts the needed fields, makes setup and starts working.
- It is assumed that always full and correct cfg is provided. No need in defaults and additional checks (except few cases).
- If any problem, the module throws an exception.

- Every module has an additional updateCfg() method where cfg update is provided.
- The module extracts the fields related to it (if any) and makes an update in settings. How is it done - is a module-specific.
- It is assumed that always correct cfg update is provided. No need in defaults and additional checks (except few cases).
- If any problem, the module throws an exception.

After Imp-Device restart:
  - If it is a new deployment and ERASE_FLASH builder-variable is defined, erase the flash.
  - If there is saved cfg in the flash, actual_cfg = saved cfg, use it to setup and start all modules.
    -- If an exception or any other problems (eg. with reading cfg from the flash), log the error, erase saved cfg in the flash and restart Imp-Device.
  - If there is no saved cfg in the flash, actual_cfg = default cfg, use it to setup and start all modules.
    -- If an exception, log the error, go to recovery mode (TBD).
  - If all modules are started w/o problems, send actual_cfg to Imp-Agent.

When cfg update comes from Imp-Agent:
  - Wait (using Promises or whatever, TBD) till any other cfg setup/update process is completed. Including completion of initial setup after Imp-Device restart.
  - I.e. actual_cfg always exists.
  - Make a diff between actual_cfg and cfg update.
  - Call updateCfg(diff) for all modules.
    -- If an exception, log the error, restart Imp-Device.
  - If no problems:
    -- actual_cfg = actual_cfg + diff
    -- save actual_cfg in the flash
       - if problems - ignore / erase flash (TBD)
    -- send actual_cfg to Imp-Agent.
  - When to confirm cfg update message receiving - TBD

Recovery Mode
-------------
If an unhandled error occurred (or there are other conditions when need to go to the recovery mode - TBD), device goes to sleep and periodically connects to the server waiting for a SW update
